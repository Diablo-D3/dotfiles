#!/usr/bin/env bash

###
### Boilerplate
###

# Exit immediately if a command exits with a non-zero status
set -e

# If set, the ERR trap is inherited by shell functions
set -E

# Treat unset variables as an error when substituting
set -u

# Return value of a pipeline is the last command to exit with a non-zero status
set -o pipefail

# Mark variables which are modified or created for export
set -a

# Allows patterns which match no files to expand to a null string
shopt -s nullglob

# Allow ** pattern
shopt -s globstar

# Allow extended regular expressions
shopt -s extglob

# Allow spaces in filenames and not explode
# https://dwheeler.com/essays/fixing-unix-linux-filenames.html
IFS="$(printf '\n\t')"

GREEN="$(tput setaf 2)"
RESET="$(tput sgr0)"
OFFSET=0

###
### Job Block Markers
###

# Start of a block of jobs
function _start() {
    if [ $OFFSET -ne 0 ]; then
        OFFSET=0
        echo -e ""
    fi

    echo -e "$GREEN==> $1$RESET"
}

# End of a block of jobs
function _end() {
    OFFSET=0
    echo -e ""
}

# Status of the job
function _status() {
    OFFSET=1
    echo -e "$*"
}

###
### Status checks
###

# performs a status check, should be used by one of its wrappers
function _check_status() {
    local target="$1"
    local new="$2"
    local ext="$3"
    local func="$4"

    local changed=false
    local old state dirname basename

    dirname="$(dirname "$target")"
    basename="$(basename "$target")"

    if [[ "$basename" != "."* ]]; then
        state="$dirname/.$basename.$ext"
    else
        state="$dirname/$basename.$ext"
    fi

    if [ ! -e "$state" ]; then
        changed=true
    else
        # shellcheck disable=SC2034
        old=$(<"$state")

        eval "$func" && changed=true
    fi

    if "$changed"; then
        cat <<<"$new" >"$state"
    fi

    echo "$changed"
}

# check if one or more files were modified by tracking checksum
function _check_file() {
    local changed=false

    for file in "$@"; do
        local new
        new=$(git hash-object "$file")

        if eval "$(_check_status "$file" "$new" "sum" "[ \$new != \$old ]")"; then
            changed=true
        fi
    done

    echo "$changed"
}

# check if one or more git repos were modified by tracking revision
function _check_repo() {
    local changed=false

    for repo in "$@"; do
        local new
        new=$(git -C "$repo" rev-parse HEAD)

        if eval "$(_check_status "$repo" "$new" "rev" "[ \$new != \$old ]")"; then
            changed=true
        fi
    done

    echo "$changed"
}

# check if we've recently interacted with a file by timer
function _check_time() {
    _check_status "$1" "$(date +%s)" "time" "[ \$new -gt \$((\$old + $2)) ]"
}

# check if the supplied version has recently changed
function _check_ver() {
    _check_status "$1" "$2" "ver" "[ \$new != \$old ]"
}

###
### Wrappers
###

# mkdir with create parents
function _mkdir {
    mkdir -vp "$1"
}

# ln, but cp when doing /etc autorule or into Windows from WSL2, only ln/cp
# files, not directories, for safety/sanity
function _ln {
    _mkdir "$(dirname "$2")"
    rm -f "$2"
    if [[ "$2" != "/mnt/c"* ]] && [[ "$2" != "/etc"* ]]; then
        ln -sTv "$1" "$2"
    else
        cp -Tv "$1" "$2"
    fi
}

# ln every file and mkdir every dir recursively, and retain . for hidden
# destinations
function _ln_descent {
    SRC_DIR="$1"
    DST_DIR="$2"

    if [[ "$DST_DIR" != */ ]] && [[ "$DST_DIR" != *. ]]; then
        DST_DIR="$DST_DIR/"
    fi

    for SRC in "$SRC_DIR"/**; do
        if [ -f "$SRC" ]; then
            DST="${SRC#$SRC_DIR/}"
            _ln "$SRC" "${DST_DIR}${DST}"
        elif [ -d "$SRC" ]; then
            _mkdir "${DST_DIR}${SRC#$SRC_DIR/}"
        else
            _status "Cannot handle $SRC"
        fi
    done
}

# run command with sudo while making install-lib functions available
function _sudo() {
    if [[ $(groups "$USER") == *"sudo"* ]]; then
        local IFS=" "
        sudo -E bash -c "source $BASE_DIR/install-lib; $*"
    else
        _status "Cannot become root: " "$@"
    fi
}

###
### OS Wrappers
###

# run scoop, even when path is screwy
function _scoop() {
    # Scoop uses a batch file somewhere, cwd cannot be a UNC path
    OLDPWD="$(pwd)"
    cd "/mnt/c"

    # Always put Scoop first in path while running Scoop
    # Scoop will not be in path when first installed
    OLDPATH="$PATH"
    export PATH="$SCOOP_DIR:$PATH"

    "$SCOOP" "$@"

    # Reset cwd and path
    cd "$OLDPWD"
    unset OLDPWD

    export PATH="$OLDPATH"
    unset OLDPATH
}
