#!/bin/bash

# shellcheck disable=SC1090  # can't follow non-constant source
# shellcheck disable=SC1091  # can't follow source
# shellcheck disable=SC2034  # unused variables

# if not interactive, exit early
[ -z "${PS1+unset}" ] && return
shopt -oq posix && return
[ "$TERM" = "dumb" ] && return

# if xterm or tmux, assume 24 bit support
if [[ "$TERM" = "xterm"* || "$TERM" = "tmux"* ]]; then
  export COLORTERM="truecolor"
fi

# path: home, $PATH, sbin
# global is assumed to contain at least: /usr/local/bin:/usr/bin:/bin
PATH=$HOME/bin:$PATH:/usr/local/sbin:/usr/sbin:/sbin

# noramlize locale
LANG=en_US.UTF-8
LC_ALL=$LANG
LC_CTYPE=$LANG

# set window size
shopt -s checkwinsize

# recursive glob
shopt -s globstar 2>/dev/null

# case-insensitive glob
shopt -s nocaseglob

# append, not overwrite, history
shopt -s histappend

# save multi-line commands as single entry with embeded newlines
shopt -s cmdhist
shopt -s lithist

# force expand variable in tab complete to prevent escaping $
shopt -s direxpand

# unlimited power
HISTSIZE=9001
HISTFILESIZE=9001

# ignore deps
HISTCONTROL="erasedups:ignoreboth"

# don't record useless commands
HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear"

# ignore case for autocomplete
bind "set completion-ignore-case on"

# ... including - and _
bind "set completion-map-case on"

# don't require tab twice to get list
bind "set show-all-if-ambiguous on"

# treat symlinked dirs as dirs
bind "set mark-symlinked-directories on"

# colors and paren matching
bind "set blink-matching-paren on"
bind "set colored-completion-prefix on"
bind "set colored-stats on"

# add bash-completion when available
if [ -f /usr/share/bash-completion/bash_completion ]; then
  source /usr/share/bash-completion/bash_completion
elif [ -f /etc/bash_completion ]; then
  source /etc/bash_completion
fi

# add git-prompt when available
GIT_PS1_SHOWCOLORHINTS=true
GIT_PS1_SHOWDIRTYSTATE=true
GIT_PS1_SHOWSTASHSTATE=true
GIT_PS1_SHOWUNTRACKEDFILES=true
GIT_PS1_SHOWUPSTREAM=auto

if [[ -e /usr/share/git/completion/git-prompt.sh ]]; then
  source /usr/share/git/completion/git-prompt.sh
elif [[ -e /usr/lib/git-core/git-sh-prompt ]]; then
  source /usr/lib/git-core/git-sh-prompt
fi

function sgr {
  echo -e "\\[\e[$1m\\]"
}

function col {
  sgr "38;5;$1"
}

# styles
RESET=$(sgr 0)

BOLD=$(sgr 1)
DIM=$(sgr 2)
NORM=$(sgr 22)

SITA=$(sgr 3)
RITA=$(sgr 23)
SUL=$(sgr 4)
RUL=$(sgr 24)
SREV=$(sgr 7)
RREV=$(sgr 27)

# colors
BLACK=$(col 0)
RED=$(col 1)
GREEN=$(col 2)
YELLOW=$(col 3)
BLUE=$(col 4)
MAGENTA=$(col 5)
CYAN=$(col 6)
WHITE=$(col 7)
HIBLACK=$(col 8)
HIRED=$(col 9)
HIGREEN=$(col 10)
HIYELLOW=$(col 11)
HIBLUE=$(col 12)
HIMAGENTA=$(col 13)
HICYAN=$(col 14)
HIWHITE=$(col 15)

# hostname color
HOSTCHECKSUM=$(echo "$HOSTNAME" | md5sum | tr '[:lower:]' '[:upper:]' | cut -b1-2)
HOSTCOLOR=$((16#"$HOSTCHECKSUM" % 16))

case $HOSTCOLOR in
  0)
    PRO_FG=$REV$(col $HOSTCOLOR)
    ;;
  *)
    PRO_FG=$(col $HOSTCOLOR)
    ;;
esac

unset HOSTCHECKSUM
unset HOSTCOLOR

# set prompt
PRO_START="${RESET}[${PRO_FG}\\h${RESET} \\W"

if [ "$(id -u)" -eq 0 ]; then
  PRO_END="]${RED}#${RESET} "
else
  PRO_END="]\$ "
fi

precmd() {
  if [ "$PWD" != "$HOME" ] && [ "$(type -t __git_ps1)" = "function" ]; then
    __git_ps1 "$PRO_START" "$PRO_END"
  else
    PS1="${PRO_START}${PRO_END}"
  fi

  if [ -n "$TMUX" ]; then
    eval "$(tmux show-environment -s)"
  fi

  history -a
}

PROMPT_COMMAND=precmd

# set xterm title
preexec() {
  if [ "$BASH_COMMAND" == "precmd" ]; then
    COMMAND="${DIRSTACK[*]}"
  else
    COMMAND="$BASH_COMMAND"
  fi

  PRO_TITLE="\e]0;${HOSTNAME%%.*}: $COMMAND\a"
  echo -ne "$PRO_TITLE"
}

trap preexec DEBUG

# load local Win config, don't overwrite PATH unless Win paths are missing
if [[ -e ~/.bashrc.win ]]; then
  OLDPATH="$PATH"

  source ~/.bashrc.win

  if [[ "$OLDPATH" == *"/mnt/c"* ]]; then
    PATH="$OLDPATH"
  else
    PATH="$OLDPATH:$PATH"
  fi
fi

# aliases
alias bc="bc -ql"
alias grep="grep --color=auto"
alias ls="ls --color=auto"

# rust/cargo
PATH="$HOME/.cargo/bin:$PATH"

# nodejs/npm
NODE_PATH="$HOME/.npm/lib/node_modules"

PATH="$HOME/.npm/bin:$PATH"
MANPATH="$NPM_PACKAGES/share/man"

# emacs
if [ -f /usr/bin/emacs ]; then
  PATH="$HOME/.emacs.d/bin:$PATH"

  export ALTERNATE_EDITOR=""
  export EDITOR=emacswrapper

  alias emacs="emacswrapper"
else
  export EDITOR=vim
fi

export VISUAL="$EDITOR"
export GIT_EDITOR="$EDITOR"

alias e='$EDITOR'

# fzf and fd
FZF_DEFAULT_OPTS="--height 50% +m -1 -0 --bind tab:down,btab:up"
FZF_COMPLETION_TRIGGER=""

if [ -f /usr/bin/fdfind ]; then
  alias fd="fdfind"
fi

if command -v fd >/dev/null 2>&1; then
  _fzf_compgen_path() {
    fd --hidden --follow --exclude ".git" . "$1"
  }

  _fzf_compgen_dir() {
    fd --type d --hidden --follow --exclude ".git" . "$1"
  }
fi

if [ -f /usr/share/bash-completion/completions/fzf ]; then
  source /usr/share/bash-completion/completions/fzf
fi

if [ -f /usr/share/doc/fzf/examples/key-bindings.bash ]; then
  source /usr/share/doc/fzf/examples/key-bindings.bash
fi

# scoop
if [ -v USERPROFILE ] && [ -d "${USERPROFILE}/scoop/shims" ] && [[ $PATH != *"scoop"* ]]; then
  PATH="$PATH:${USERPROFILE}/scoop/shims"
fi
